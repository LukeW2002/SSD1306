#include <libopencm3/stm32/gpio.h>
#include <libopencm3/stm32/usart.h>
#include <libopencm3/stm32/i2c.h>

#include "pentacom_font.h"
#include "firmwareSSD1306.h"

#include <stdlib.h>

uint32_t displayI2C = I2C1;
uint8_t displayAddress = DEFAULT_ADDRESS;
uint8_t WIDTH = 128;
uint8_t HEIGHT = 32;
uint16_t screenBuffer = DEFAULTBUFFER;

#define I2C_PORT GPIOB
#define I2C_SCL GPIO8
#define I2C_SDA GPIO9

void usartSendString(const char *str)
{
    while (*str)
    {
        usart_send_blocking(USART2, *str);
        str++;
    }
	usart_send_blocking(USART2, '\n');
	usart_send_blocking(USART2, '\r');
}

//RANDOM NOISE STOLEN FROM THE RUSSIAN DUDE
uint8_t screenRAM[DEFAULTBUFFER] = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1e,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xc0
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xc0,0x30
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x1f,0xff,0xff,0xff,0xfe,0x00,0x00,0x00,0x3c,0x0c
    ,0x00,0x00,0x00,0x00,0x00,0x03,0xf0,0x03,0xe7,0xf6,0x01,0xf0,0x00,0x00,0x07,0x03
    ,0x00,0x08,0x00,0x00,0x00,0x3c,0x10,0x3c,0x78,0x01,0x80,0x0f,0x00,0x00,0x00,0xe0
    ,0x00,0x08,0x00,0x00,0x03,0xc0,0x21,0xc7,0x80,0x00,0x40,0x00,0xe0,0x00,0x00,0x18
    ,0x00,0x08,0x00,0x00,0x3c,0x00,0x46,0x38,0x00,0x00,0x20,0x00,0x18,0x00,0x00,0x06

    ,0x00,0x08,0x00,0x00,0xc7,0xfc,0x48,0x40,0x00,0x00,0x20,0x00,0x04,0x00,0x00,0x01
    ,0x00,0x08,0x00,0x03,0x38,0x03,0x90,0x80,0x00,0x01,0xff,0xe0,0x02,0x00,0x00,0x00
    ,0x00,0x08,0x00,0x05,0xc0,0x00,0x90,0x80,0x00,0x0e,0x10,0x1c,0x01,0x80,0x00,0x00
    ,0x00,0x08,0x00,0x1e,0x00,0x00,0x90,0x80,0x00,0x18,0x10,0x02,0x00,0x80,0x00,0x00
    ,0x00,0x08,0x00,0x28,0x00,0x00,0x88,0x40,0x00,0x18,0x30,0x01,0x00,0x40,0x00,0x00
    ,0x00,0x08,0x00,0x30,0x00,0x00,0x48,0x20,0x00,0x0c,0x20,0x03,0x00,0x40,0x00,0x00
    ,0x00,0x08,0x00,0x60,0x00,0x00,0x44,0x20,0x00,0x00,0x20,0x1c,0x00,0x40,0x00,0x03
    ,0x00,0x08,0x00,0x60,0x00,0x00,0x24,0x10,0x00,0x00,0x41,0xe0,0x00,0x40,0x00,0x0e

    ,0x00,0x00,0x00,0xa0,0x00,0x00,0x32,0x0e,0x00,0x00,0xfe,0x00,0x01,0xc0,0x00,0x30
    ,0x00,0x00,0x00,0xa0,0x00,0x00,0x09,0x81,0xff,0xff,0x80,0x00,0x0e,0x00,0x01,0xc0
    ,0x00,0x00,0x00,0x90,0x00,0x00,0x04,0x40,0x00,0x06,0x00,0x00,0xf0,0x00,0x06,0x00
    ,0x00,0x00,0x00,0x8c,0x00,0x00,0x03,0x30,0x00,0x08,0x00,0x1f,0x00,0x00,0x78,0x01
    ,0x00,0x00,0x00,0x83,0x00,0x00,0x00,0xcc,0x00,0x30,0x07,0xe0,0x00,0x03,0x80,0x1e
    ,0x00,0x00,0x00,0x80,0xc0,0x00,0x00,0x33,0xff,0xff,0xf8,0x00,0x00,0x7c,0x01,0xe0
    ,0x00,0x21,0x00,0x80,0x38,0x00,0x00,0x0e,0x03,0x00,0x00,0x00,0x3f,0x80,0x3e,0x00
    ,0x00,0x7f,0x80,0x80,0x07,0x00,0x00,0x01,0xec,0x00,0x00,0x1f,0xc0,0x7f,0xc0,0x00

    ,0x00,0x00,0x00,0x40,0x00,0xfc,0x00,0x00,0x3f,0xf0,0x7f,0xef,0xff,0x80,0x00,0x00
    ,0x00,0x33,0x00,0x20,0x00,0x03,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x1e,0x00,0x06,0x00,0x00,0x03,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x02,0x00,0x01,0xf0,0x01,0xfc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x0f,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00

    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1e,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xc0
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xc0,0x30
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x1f,0xff,0xff,0xff,0xfe,0x00,0x00,0x00,0x3c,0x0c
    ,0x00,0x00,0x00,0x00,0x00,0x03,0xf0,0x03,0xe7,0xf6,0x01,0xf0,0x00,0x00,0x07,0x03
    ,0x00,0x08,0x00,0x00,0x00,0x3c,0x10,0x3c,0x78,0x01,0x80,0x0f,0x00,0x00,0x00,0xe0
    ,0x00,0x08,0x00,0x00,0x03,0xc0,0x21,0xc7,0x80,0x00,0x40,0x00,0xe0,0x00,0x00,0x18
    ,0x00,0x08,0x00,0x00,0x3c,0x00,0x46,0x38,0x00,0x00,0x20,0x00,0x18,0x00,0x00,0x06

    ,0x00,0x08,0x00,0x00,0xc7,0xfc,0x48,0x40,0x00,0x00,0x20,0x00,0x04,0x00,0x00,0x01
    ,0x00,0x08,0x00,0x03,0x38,0x03,0x90,0x80,0x00,0x01,0xff,0xe0,0x02,0x00,0x00,0x00
    ,0x00,0x08,0x00,0x05,0xc0,0x00,0x90,0x80,0x00,0x0e,0x10,0x1c,0x01,0x80,0x00,0x00
    ,0x00,0x08,0x00,0x1e,0x00,0x00,0x90,0x80,0x00,0x18,0x10,0x02,0x00,0x80,0x00,0x00
    ,0x00,0x08,0x00,0x28,0x00,0x00,0x88,0x40,0x00,0x18,0x30,0x01,0x00,0x40,0x00,0x00
    ,0x00,0x08,0x00,0x30,0x00,0x00,0x48,0x20,0x00,0x0c,0x20,0x03,0x00,0x40,0x00,0x00
    ,0x00,0x08,0x00,0x60,0x00,0x00,0x44,0x20,0x00,0x00,0x20,0x1c,0x00,0x40,0x00,0x03
    ,0x00,0x08,0x00,0x60,0x00,0x00,0x24,0x10,0x00,0x00,0x41,0xe0,0x00,0x40,0x00,0x0e

    ,0x00,0x00,0x00,0xa0,0x00,0x00,0x32,0x0e,0x00,0x00,0xfe,0x00,0x01,0xc0,0x00,0x30
    ,0x00,0x00,0x00,0xa0,0x00,0x00,0x09,0x81,0xff,0xff,0x80,0x00,0x0e,0x00,0x01,0xc0
    ,0x00,0x00,0x00,0x90,0x00,0x00,0x04,0x40,0x00,0x06,0x00,0x00,0xf0,0x00,0x06,0x00
    ,0x00,0x00,0x00,0x8c,0x00,0x00,0x03,0x30,0x00,0x08,0x00,0x1f,0x00,0x00,0x78,0x01
    ,0x00,0x00,0x00,0x83,0x00,0x00,0x00,0xcc,0x00,0x30,0x07,0xe0,0x00,0x03,0x80,0x1e
    ,0x00,0x00,0x00,0x80,0xc0,0x00,0x00,0x33,0xff,0xff,0xf8,0x00,0x00,0x7c,0x01,0xe0
    ,0x00,0x21,0x00,0x80,0x38,0x00,0x00,0x0e,0x03,0x00,0x00,0x00,0x3f,0x80,0x3e,0x00
    ,0x00,0x7f,0x80,0x80,0x07,0x00,0x00,0x01,0xec,0x00,0x00,0x1f,0xc0,0x7f,0xc0,0x00

    ,0x00,0x00,0x00,0x40,0x00,0xfc,0x00,0x00,0x3f,0xf0,0x7f,0xef,0xff,0x80,0x00,0x00
    ,0x00,0x33,0x00,0x20,0x00,0x03,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x1e,0x00,0x06,0x00,0x00,0x03,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x02,0x00,0x01,0xf0,0x01,0xfc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x0f,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

    /* I2C DATA CONTROL COMMANDS*/
void start(void)
//test
{
    i2c_send_start(displayI2C);
    while(_IF_SB(displayI2C)); // Needs to be updated. This just runs empty code until its false, It will probably get optimised out of existence by the compiler. Need to find a method of sleep which can be set relative to the frequency.
    i2c_send_7bit_address(displayI2C, displayAddress, I2C_WRITE);
    while(_IF_ADDR(displayI2C));
}

void stop(void)
{
    i2c_send_stop(displayAddress);
    while(_IF_BTF(displayAddress));
}

void sendAddress(uint8_t spec)
{
    i2c_send_data(displayAddress, spec);
    while(_IF_TxE(displayAddress));
}

void sendData(uint8_t spec, uint8_t data)
{
    usartSendString("Data sending Started");
    start();
    sendAddress(spec);
    sendAddress(data);
    stop();
    usartSendString("Success Data sent");
}

    /* REGISTER COMMANDS */
void displayOnOff (bool displaySwitch)
{
    if (displaySwitch)
    {
        sendData(COMMAND, DISPLAY_ON_RAM);
        usartSendString("Screen Turned on");
    }
    else
    {
        sendData(COMMAND, DISPLAY_NO_RAM);
        usartSendString("Screen Turned off"); 
    }
}

void setOscillatorFrequency(uint8_t value)
{
    sendData(COMMAND, SET_DISPLAY_CLOCK);
    sendData(COMMAND, value);
}

void setMultiplexRatio(uint8_t value)
{
    sendData(COMMAND, SET_MULTIPLEX_RATIO);
    sendData(COMMAND, value);
}

void setInverse(bool inverseSwitch)
{
    uint8_t value = (uint8_t) (inverseSwitch ? SET_NORMAL : SET_INVERSE);
    sendData(COMMAND, value);
}

void chargePump(bool chargePumpSwitch)
{
    sendData(COMMAND, SET_CHARGE_PUMP);
    if(chargePumpSwitch)
    {
        sendData(COMMAND, 0x14); //enable charge pump

    }
    else
    {
        sendData(COMMAND, 0x10); // Flips D2 to ON
    }
}


void setConstrast(uint8_t value)
{
    sendData(COMMAND, SET_CONTRAST_CONTROL);
    sendData(COMMAND, value);
}

void setPrecharger(uint8_t value) 
{
    sendData(COMMAND, SET_PRE_CHARGE);
    sendData(COMMAND, value);
}

void setCompPinsConfig(uint8_t value)
{
    sendData(COMMAND, SET_COM_PINS);
    sendData(COMMAND, 0b00110010 & value); // enabling left and right remap. Not sure why either.
}

void ledOnOff(bool ledSwitch)
{
    usartSendString("Initialising ledSwitch");
    if (ledSwitch == true)
    {
        sendData(COMMAND, SET_DISPLAY_ON);
        usartSendString("Led On");
    }
    else 
    {
        sendData(COMMAND, SET_DISPLAY_OFF);
        usartSendString("Led off");

    }
}

void setVcomLevel(uint8_t value)
{
    sendData(COMMAND, SET_VCOM);
    sendData(COMMAND, value);
}

void setMemoryAddressingMode(MODE mode)
{
    sendData(COMMAND, SET_MEMORY_ADDRESSING);
    sendData(COMMAND, mode);
}

void setColumnAdress(uint8_t lower, uint8_t upper)
{
    sendData(COMMAND, SET_COLUMN_ADDRESS);
    sendData(COMMAND, lower);
    sendData(COMMAND, upper);
}

void setPageAdress(uint8_t lower, uint8_t upper)
{
    sendData(COMMAND, SET_PAGE_MEMORY_ADDRESS);
    sendData(COMMAND, lower);
    sendData(COMMAND, upper);
}

void clear(void)
{
    for (uint16_t i = 0; i < screenBuffer; i++)
    {
        screenRAM[i] = 0;    
    }
}

void refresh(void)
{
    setMemoryAddressingMode(Horizontal);
    setColumnAdress(0, WIDTH - 1);
    setPageAdress(0,HEIGHT/8 - 1);
    start();
    sendAddress(DATAONLY);
    for (uint16_t i = 0; i < screenBuffer; i++)
    {
        i2c_send_data(displayI2C, screenRAM[i]);
        while (_IF_TxE(displayI2C));
    }
    stop();
}

void init(uint32_t i2c, uint8_t address, uint8_t width, uint8_t height)
{
    displayI2C = i2c;
    displayAddress = address;
    WIDTH = width;
    HEIGHT = height;
    screenBuffer = (uint16_t) ( HEIGHT / 8 * WIDTH);

    //STOLEN FROM ADAFRUIT LIBRARY
    ledOnOff(false);
    usartSendString("Step 1, Success!");

    displayOnOff(false);
    usartSendString("Step 2, Success!");

    setOscillatorFrequency(0x80);
    usartSendString("Step 3, Success!");

    setMultiplexRatio(HEIGHT - 1);
    usartSendString("Step 4, Success!");

    setInverse(false);
    usartSendString("Step 5, Success!");
    
    chargePump(true);
    usartSendString("Step 5, Success!");

    setPrecharger(0x22);
    usartSendString("Step 6, Success!");

    setCompPinsConfig(0x02);
    usartSendString("Step 7, Success!");

    setVcomLevel(0x20);
    usartSendString("Step 8, Success!");

    displayOnOff(true);
    usartSendString("Step 9, Success!");

    ledOnOff(true);
    usartSendString("Step 9, Success!");

    refresh();
    usartSendString("Step 10, Success!");
}


// RUSSIAN DUDE

void ssd1306_drawVPattern(uint8_t x, int8_t y, uint8_t pattern) {
  if ( y > HEIGHT || y < (-7) || x > WIDTH )
     return;
  uint8_t yy = abs(y) % 8;
  if ( y<0 )
    screenRAM[ y/8*WIDTH + x ] |= pattern >> yy;
  else if ( y>23 )
    screenRAM[ y/8*WIDTH + x] |= pattern << yy;
  else {
    if ( yy!=0 ) {
      screenRAM[y/8*WIDTH + x] |= pattern << yy;
      screenRAM[(y/8+1)*WIDTH + x] |= pattern >> (8-yy);
    } else
      screenRAM[y/8*WIDTH + x] |= pattern;
  }
}

void ssd1306_drawWCharStr(uint8_t x, int8_t y, color color1, WrapType wrType, wchar_t *str) {
  wchar_t symbol = 0x00;
  uint16_t curPos = 0;
  uint8_t xx = x; int8_t yy = y;
  do {
    symbol = str[curPos];
    const FontChar_t *charCur = getCharacter(symbol);
    if ((charCur->size+xx) >= (WIDTH-1) || (symbol == L'\n'))
      switch (wrType) {
        case nowrap:
          return;
        case wrapDisplay:
          xx = 0;
          yy += 8;
          break;
        case wrapCoord:
          xx = x;
          yy += 8;
      }
    for (uint8_t i=0; i<charCur->size; i++){
      uint8_t p = (color1==white) ? charCur->l[i]: ~charCur->l[i];
      ssd1306_drawVPattern(xx,yy, p);
      xx += 1;
    }
    curPos += 1;
  } while (symbol != 0x00);
}